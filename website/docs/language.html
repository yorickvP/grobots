<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><html lang=en><link rel=stylesheet title="Grobots Style" href="../grobots.css" media=all type="text/css"><link rel=home href="../" title="Grobots Main"><link rel=contents href="./" title="Documentation Contents"><link rel=up href="./"><link rel=prev href='structure.html' title='Side file structure'><link rel=next href='hardware.html' title='Hardware reference'><link rel=made href='mailto:dschudy@yahoo.com,wschudy@wpi.edu?subject=Grobots'><title>Grobots - Documentation - Language</title><h1><a href='../'>Grobots</a> - <a href='./'>Documentation</a> - Language</h1><p>Grobots are programmed in a simple stack-based language derived from Forth. This imitates RoboWar, but the language itself is much closer to Forth. These stack-based languages are good for this sort of application because they are very easy to implement, and easier to learn and use than other similarly low-level languages.<p>The Grobots language doesn't have a name yet; I will call it Grobocode here for lack of a better name. If you are used to RoboTalk, you will find it pleasantly powerful. If you are used to Forth, you will find it annoyingly underpowered. If you don't know any stack-based languages, you will just find it weird.<h3>Introduction</h3><p>Like all Forth dialects, keeps intermediate results of calculations on a stack: operands are pushed onto the stack, and operators take their arguments from the stack. Expressions are written in postfix order - the operator comes after all its arguments. This may be unfamiliar, but fortunately it doesn't take long to get used to. What in a conventional language would be:<pre><code>gamma = 1 / sqrt(1 - (v / c)^2)</code></pre>is in Grobots:<pre><code>1 v c / square - sqrt reciprocal gamma!</code></pre><p>Here's how it works. Start with an empty stack, and execute the first instruction,<code>1</code>, which pushes a value on the stack.<pre>stack: <code class=misc>1</code>  Then <code>v</code>, which pushes the value of that variable:stack: <code class=misc>1 201285</code>  Then <code>c</code>:stack: <code class=misc>1 201285 299780</code>  <code>/</code> takes the top two arguments and leaves their quotient:stack: <code class=misc>1 0.6714</code>  <code>square</code> takes one argumentstack: <code class=misc>1 0.45</code>  <code>-</code>stack: <code class=misc>0.55</code>  <code>sqrt</code>stack: <code class=misc>0.7416</code>  <code>reciprocal</code>stack: <code class=misc>1.35</code>  <code>gamma!</code> stores the value into the variable of that name.(empty stack)</pre><p>Try clicking on a robot and opening the Debugger window. Then pause the simulation and give the Step Brain command to slowly advance the brain. Watch the stack change.<p>There are instructions to operate on the stack, so you can do fancier things like using a result more than once, or shuffling things to be in the right order:<pre><code>fibonacci: ;n -- f_n  dup 1 &lt;= if drop 1 return then  dup 1 - fibonacci swap 2 - fibonacci +return</code></pre><p>See if you can understand how that works. (You'll need to look up a lot of the operators, and this may be confusing to trace since it's recursive.) <code>n -- f_n</code> is a stack diagram, saying the newly defined fibonacci operator takes one argument (n) and returns one result (f_n).<p>The most confusing errors are stack underflow and overflow. Underflow means means you tried to remove more values from the stack than were actually there. For example, <code>2 +</code> will probably underflow, because <code>+</code> needs two arguments. Overflow means you kept leaving values on the stack, so they piled higher and higher until the interpreter gave up.<h2>Model details</h2><p>Grobocode runs on a two-stack machine, like traditional Forth. There is a return stack, which is only used for return addresses, and a data stack, used for arguments and return values of operators.<p>The only data type is a 32-bit fixed-point number, with 12 bits of fraction (and 1 of sign and 19 of integer). The range is about +/- 524,288, and the precision 1/4096 (.00024). Integer values may be used as addresses.<h2>Syntax</h2><p>Grobocode syntax is a sequence of words separated by white space. There are several kinds of words; suffixes are sometimes used to indicate which kind. Each word (except compile-time words and label declarations) compiles to one instruction.<table><col><col><col><tr><th>Kind of word<th>Suffix<tr><td>Primitive call<td>none<tr><td>Read variable (including constants, vector variables, and hardware variables)<td>none<tr><td>Write variable<td><code>!</code><tr><td>Read label (put its address on the stack)<td><code>&amp;</code><tr><td>Call label<td><code>^</code> (optional)<tr><td>Declare label<td><code>:</code><tr><td>Immediate number<td>none</table><p>Semicolon makes a comment to the end of the line. This works everywhere, not just in code.<p>Variables and constants are defined somewhat clumsily by leaving the language and using reader tags. <code>#var <var>name</var> <var>initial-value</var></code> defines a variable, <code>#vector <var>name</var> <var>initial-x</var> <var>initial-y</var></code> defines a vector variable, and <code>#const <var>name</var> <var>value</var></code> defines a constant.<h2>Primitive Operators</h2><p>Hardware access words are not included here, but are listed on the <a href='hardware.html'>hardware</a> page.<table><col width='15%'><col width='20%'><col><tr><th>Word<th>Stack diagram<th>Comments<tr><td><code>nop</code><td>--<td>Does nothing, of course. Used for padding in jump tables.<tr><th colspan=3>Stack manipulation<tr><td><code>drop</code><td>a --<td>Discard the top item on the stack.<tr><td><code>2drop</code><td>a b --<td>Discard the top two items.<tr><td><code>nip</code><td>a b -- b<td>Discard the second item on the stack.<tr><td><code>rdrop</code><td>R: a --<td>Discard the top item on the return stack.<tr><td><code>dropn</code><td> x<sub>n</sub> ... x<sub>2</sub> x<sub>1</sub> n --<td> remove <var>n</var> items from the stack.<tr><td><code>swap</code><td>a b -- b a<td>Exchange the top two items.<tr><td><code>2swap</code><td>a b c d -- c d a b<td>Exchange the top two pairs of items.<tr><td><code>rot</code><td>a b c -- b c a<td><tr><td><code>rrot</code><td>a b c -- c a b<td><tr><td><code>dup</code><td>a -- a a	<td rowspan=5>These all duplicate items that are on the stack.<tr><td><code>2dup</code><td>a b -- a b a b<tr><td><code>tuck</code><td>a b -- b a b<tr><td><code>over</code><td>a b -- a b a<tr><td><code>2over</code><td>a b c d -- a b c d a b<tr><td><code>stack</code><td>-- height<td>Return the number of items that were on the stack.<tr><td><code>stack-limit</code><td>-- limit<td>Return the maximum number of items that can be on the stack.<tr><td><code>pick</code><td> x<sub>n</sub> ... x<sub>2</sub> x<sub>1</sub> n -- x<sub>n</sub> ... x<sub>2</sub> x<sub>1</sub> x<sub>n</sub><td>copy the <var>n</var>th item to the top of the stack.<tr><td><code>&gt;r</code><td>a -- R: -- a	<td rowspan=2>Move an item to or from the return stack. The item must be a valid address, so these instructions are not very useful.<tr><td><code>r&gt;</code><td>-- a R: a --<tr><th colspan=3>Branches<tr><td><code>jump</code><td>address --<td>Continue execution from address.<tr><td><code>call</code><td>address -- R: -- pc<td>Push the address of the next instruction on the return stack, and continue execution from address.<tr><td><code>return</code><td>R: address --<td>Remove address from the return stack and continue from it.<tr><td><code>ifg</code><td>flag address --<td>Jump to address if flag is nonzero.<tr><td><code>nifg</code><td>flag address --<td>Jump to address if flag is zero.<tr><td><code>ifeg</code><td>flag addr1 addr2 --<td>Jump to addr1 if flag is nonzero or to addr2 if it is zero.<tr><td><code>ifc</code><td>flag address -- [R: -- pc]<td>Call address if flag is nonzero.<tr><td><code>ifec</code><td>flag addr1 addr2 -- R: -- pc<td><tr><td><code>nifc</code><td>flag address -- [R: -- pc]<td>Call address if flag is zero.<tr><td><code>ifr</code><td>flag -- [R: address --]<td>Returns (to the top address on the return stack) if flag is nonzero.<tr><td><code>nifr</code><td>flag -- [R: address --]<td>Returns if flag is zero.<tr><th colspan=3>Arithmetic etc.<tr><td><code>+</code><td>a b -- a+b<td><tr><td><code>-</code><td>a b -- a-b<td><tr><td><code>negate</code><td>a -- -a<td><tr><td><code>*</code><td>a b -- a*b<td><tr><td><code>/</code><td>a b -- a/b<td><tr><td><code>reciprocal</code><td>a -- 1/a<td><tr><td><code>mod</code><td>a b -- r<td><tr><td><code>rem</code><td>a b -- r<td><tr><td><code>square</code><td>a -- a^2<td><code>square: dup * return</code><tr><td><code>sqrt</code><td>a -- s<td>square root<tr><td><code>exponent</code><td>b x -- b^x<td><tr><td><code>is-integer</code><td>a -- flag<td><tr><td><code>floor</code><td>a -- n<td>Rounds down.<tr><td><code>ceiling</code><td>a -- n<td>Rounds up.<tr><td><code>round</code><td>a -- n<td>Rounds to nearest.<tr><td><code>min</code><td>a b -- a|b<td>Returns the lesser (closer to negative infinity) of the arguments.<tr><td><code>max</code><td>a b -- a|b<td>Returns the greater (closer to positive infinity) of the arguments.<tr><td><code>abs</code><td>a -- b<td>b = |a|<tr><td><code>signum</code><td>a -- b<td>b = 1 if a positive, -1 if negative, 0 otherwise.<tr><td><code>reorient</code><td>a -- b<td>Ensures an angle is in (-pi, pi].<tr><td><code>sin</code><td>a -- sina<td><tr><td><code>cos</code><td>a -- cosa<td><tr><td><code>tan</code><td>a -- tana<td><tr><td><code>arcsin</code><td>sina -- a<td><tr><td><code>arccos</code><td>cosa -- a<td><tr><td><code>arctan</code><td>tana -- a<td><tr><td><code>arctan2</code><td>x y -- a<td><tr><td><code>random</code><td>min max -- value<td>Returns a random real value evenly distributed between the two bounds (inclusive).<tr><td><code>random-angle</code><td>-- angle<td>Returns a random value evenly distributed in (-pi, pi].<tr><td><code>random-int</code><td>min max -- value<td>Returns a random integer evenly distributed between the two bounds (inclusive). The bounds need not be integers, but the result will be; <code>1.5 2.5 random-int</code> returns 2.<tr><td><code>random-bool</code><td>probability -- boolean<td>Returns a boolean, which will be 1 with the given probability.<tr><td><code>pi</code><td>-- pi<td><tr><td><code>2pi</code><td>-- 2pi<td><tr><td><code>pi/2</code><td>-- pi/2<td><tr><td><code>e</code><td>-- e<td>2.7182818284<tr><td><code>epsilon</code><td>-- epsilon<td>Returns the smallest difference representable.<tr><td><code>infinity</code><td>-- inf<td>Returns the largest positive value representable. (Negative infinity is actually <code>infinity negate epsilon -</code>.)<tr><th colspan=3>Vector operations<tr><td><code>rect-to-polar</code><td>x y -- magnitude angle<td>Convert a vector from rectangular to polar form.<tr><td><code>polar-to-rect</code><td>magnitude angle -- x y<td>Convert a vector from polar to rectangular form.<tr><td><code>v+</code><td>x1 y1 x2 y2 -- x1+x2 y1+y2<td>Adds two vectors in rectangular form.<tr><td><code>v-</code><td>x1 y1 x2 y2 -- x1-x2 y1-y2<td>Subtracts two vectors in rectangular form.<tr><td><code>vnegate</code><td>x y -- -x -y<td>Negates a vector.<tr><td><code>vs*</code><td>x y s -- x*s y*s<td>Vector-scalar multiply.<tr><td><code>vs/</code><td>x y s -- x/s y/s<td>Vector-scalar divide.<tr><td><code>norm</code><td>x y -- p<td>Returns <code>x square y square + sqrt</code>, the Pythagorean sum.<tr><td><code>angle</code><td>x y -- angle<td>Returns arctan2(y, x).<tr><td><code>dot</code><td>x1 y1 x2 y2 -- v<td>Dot product. v = <code>x1 x2 * y1 y2 * +</code><tr><td><code>project</code><td>x1 y1 x2 y2 -- x3 y3<td>Returns the projection of the first vector onto the second.<tr><td><code>cross</code><td>x1 y1 x2 y2 -- v<td>Two-dimensional cross product, sort of. v = <code>x1 y2 * y1 x2 * -</code>. This is the z-component of the equivalent three-dimensional cross product.<tr><td><code>unitize</code><td>x y -- x' y'<td>Returns a vector of magnitude 1 in the same direction.<tr><td><code>dist</code><td>x1 y1 x2 y2 -- d<td>Distance (norm of difference) operator.<tr><td><code>in-range</code><td>x1 y1 x2 y2 r-- flag<td>whether the two vectors differ by less than r.<tr><td><code>v=</code><td>x1 y1 x2 y2 -- flag<td>Returns whether the vectors are equal.<tr><td><code>v&lt;&gt;</code><td>x1 y1 x2 y2 -- flag<td><tr><th colspan=3>Comparisons and Boolean operations<tr><td><code>=</code><td>a b -- flag<td><tr><td><code>&lt;&gt;</code><td>a b -- flag<td><tr><td><code>&lt;</code><td>a b -- flag<td><tr><td><code>&gt;</code><td>a b -- flag<td><tr><td><code>&lt;=</code><td>a b -- flag<td><tr><td><code>&gt;=</code><td>a b -- flag<td><tr><td><code>not</code><td>f1 -- f2<td>f2 is zero if f1 was nonzero, and one otherwise.<tr><td><code>and</code><td>f1 f2 -- f3<td>f3 is one if both f1 and f2 were nonzero, and zero otherwise.<tr><td><code>or</code><td>f1 f2 -- f3<td>f3 is zero if both f1 and f2 were zero, and one otherwise.<tr><td><code>xor</code><td>f1 f2 -- f3<td>f3 is one if exactly one of f1 or f2 was non-zero, and zero otherwise.<tr><td><code>nand</code><td>f1 f2 -- f3<td>f3 is zero if both f1 and f2 were nonzero, and one otherwise.<tr><td><code>nor</code><td>f1 f2 -- f3<td>f3 is one if both f1 and f2 were zero, and zero otherwise.<tr><td><code>ifev</code><td>flag a b -- a|b<td>Value conditional: returns a if flag was nonzero, and b otherwise.<tr><th colspan=3>Miscellaneous<tr><td><code>print</code><td>value --<td>Remove and display one item, for debugging purposes.<tr><td><code>vprint</code><td>x y --<td>Remove and display a vector.<tr><td><code>beep</code><td>--<td>Beep, for debugging purposes.<tr><td><code>pause</code><td>--<td>Pauses the simulation. For debugging.<tr><td><code>stop</code><td>--<td>Permanently stops execution of this brain.<tr><td><code>sync</code><td>--<td>Waits until the next frame to continue execution. Useful for waiting for hardware to work, or for synchronizing to do something all in one frame.<tr><td><code>store</code><td>x addr --<td>Writes a value to local memory.<tr><td><code>load</code><td>addr -- x<td>Reads local memory.<tr><td><code>vstore</code><td>x y addr --<td>A convenience, to store two values.<tr><td><code>vload</code><td>addr -- x y<td></table><h2>Compile-Time Words</h2><p>Some words execute at compile time, for convenience in writing common control structures. There are conditionals and loops so far.<table width='100%'><col width='30%'><col width='30%'><col width='40%'><tr><th>Structure<th>Meaning<th>Expansion<tr><td><code><var>test</var> if <var>body</var> then</code>	<td>execute <var>body</var> if <var>test</var> is true	<td><code><var>test</var> <var>label</var>& nifg <var>body</var> <var>label</var>:</code><tr><td><code><var>test</var> if <var>body1</var> else <var>body2</var> then</code>	<td>execute <var>body1</var> if <var>test</var> is true, <var>body2</var> otherwise	<td><code><var>test</var> <var>skip</var>& nifg <var>body1</var> <var>done</var>& jump<br>		<var>skip</var>: <var>body2</var> <var>done</var>:</code><tr><td><code>nif</code> ...	<td>If, with sense reversed	<td><code><var>test</var> <var>label</var>& ifg</code> ...<tr><td><code><var>test1</var> if <var>test2</var> and-if <var>body1</var> else <var>body2</var> then</code>	<td>if <var>test1</var> is true, then if <var>test2</var> is true, then execute <var>body1</var>...	<td><code><var>test</var> <var>skip</var>& nifg <var>test2</var> <var>skip</var>& nifg <var>body1</var> <var>done</var>& jump<br>		<var>skip</var>: <var>body2</var> <var>done</var>:</code><tr><td><code><var>test1</var> if <var>body1</var> else <var>test2</var> if <var>body2</var> celse <var>test3</var> if <var>body3</var> celse <var>body4</var> then</code>	<td>Makes if-elsif-elsif-else constructs shorter (no need to write <code>then then then</code>).	<td><code><var>test1</var> <var>skip1</var>& nifg <var>body1</var> <var>done</var>& jump<br>		<var>skip1</var>: <var>test2</var> <var>skip2</var>& nifg <var>body2</var> <var>done</var>& jump<br>		<var>skip2</var>: <var>test3</var> <var>skip3</var>& nifg <var>body3</var> <var>done</var>& jump<br>		<var>skip3</var>: <var>body4</var> <var>done</var>:</code><tr><td><code>do <var>code</var> forever</code>	<td>infinite loop	<td><code><var>repeat</var>: <var>code</var> <var>repeat</var>& jump</code><tr><td><code>do <var>test</var> while <var>code</var> loop</code>	<td rowspan=2>Execute <var>test</var> and <var>code</var> until <var>test</var> is true (<code>until</code>) or false (<code>while</code>). Note that the end-test is in the middle of the loop.	<td><code><var>repeat</var>: <var>test</var> <var>done</var>& nifg<br>		<var>code</var> <var>repeat</var>& jump <var>done</var>:</code><tr><td><code>do <var>test</var> until <var>code</var> loop</code>	<td><code><var>repeat</var>: <var>test</var> <var>done</var>& ifg<br>		<var>code</var> <var>repeat</var>& jump <var>done</var>:</code><tr><td><code>do <var>code</var> <var>test</var> while-loop</code>	<td rowspan=2> optimized versions of <code>while loop</code> and <code>until loop</code>, saving two instructions	<td><code><var>repeat</var>: <var>code</var> <var>test</var> <var>repeat</var>& ifg</code><tr><td><code>do <var>code</var> <var>test</var> until-loop</code>	<td><code><var>repeat</var>: <var>code</var> <var>test</var> <var>repeat</var>& nifg</code></table><p><address><a href='../'>Grobots</a> by Devon Schudy (<a href='mailto:dschudy@yahoo.com?subject=Grobots'>dschudy@yahoo.com</a>)and <a href="http://users.wpi.edu/~wschudy/">Warren Schudy</a> (<a href="mailto:wschudy@wpi.edu?subject=Grobots">wschudy@wpi.edu</a>)</address>