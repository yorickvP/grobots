<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><html lang=en><link rel=stylesheet title="Grobots Style" href="../grobots.css" media=all type="text/css"><link rel=home href="../"><link rel=contents href="./" title="Documentation Contents"><link rel=up href="./"><link rel=made href='mailto:dschudy@yahoo.com,wschudy@wpi.edu?subject=Grobots'><title>Grobots - Documentation - Tutorial</title><h1><a href='../'>Grobots</a> - <a href='./'>Documentation</a> - Tutorial</h1><p>Here is a rudimentary tutorial, built around sample types. It assumes you already know how to load sides and run rounds, and have some idea how a stack-based <a href='language.html'>language</a> works.<p>You probably won't go through this tutorial in order. You probably won't build sides very similar to the examples. But the examples will show you what's important, what you should learn, and what you can imitate. Not everything is explained, so don't hesitate to look things up.<p>Additional examples and explanations (or even just suggestions) are eagerly accepted.<h3>Growing</h3><p>The simplest side that reproduces:<pre><code>#side Tutorial#color FD4#type Vegetable#hardware  solar-cells .4  constructor .4  armor 50  processor 2#codedo  autoconstructforever#end</code></pre><p><code>do ... forever</code> is an infinite loop. Most types have at least one of these. <code>autoconstruct</code> turns the constructor on and off as energy is available.<h3>Shooting</h3><p>Vegetables are delicious, and many sides will kill and eat them. Let's give them a weapon.<pre><code>#type Killer Vegetable#color F0E#hardware  solar-cells .3  constructor .3  armor 100  processor 5  energy 100 0  grenades 30 15 34  robot-sensor 15#codedo  autoconstruct  grenades-reload-time periodic-robot-sensor if    robot-found if      robot-position robot-velocity lead-grenade    then  thenforever</code></pre><p>Obviously you need something to shoot at, so load up some other sides if you haven't already.<p><code><var>test</var> if <var>body</var> then</code> is a conditional, written in a different order than in most languages.<p><code>periodic-robot-sensor</code> takes an argument, and fires the robot sensor if that many frames have passed. Using <code>grenades-reload-time</code> as the argument gives the weapon just enough time to reload between scans.<p><code>lead-grenade</code> is a convenient operator for shooting at moving targets. If you replace <code>robot-position robot-velocity lead-grenade</code> with <code>robot-distance robot-direction fire-grenade</code> and test against some moving targets, you can see why shot-leading matters.<h3>Eating</h3><p>Vegetable grows very slowly, especially if it spends energy buying weapons. Let's make a type which eats manna, so it can grow faster.<pre><code>#type Animal#color#hardware  engine .05  constructor 1  eater 2  energy 250 25  food-sensor 8  processor 5  armor 100#codedo  autoconstruct  44 periodic-food-sensor drop  food-found if    food-position seek-location  else    0 engine-power!  thenforever</code></pre><p><code>periodic-food-sensor</code> returns a boolean indicating whether it fired the sensor, but since we don't care, we use <code>drop</code> to stop the results from piling up on the stack.<p><code>seek-location</code> sets the engine to move toward the coordinates given as arguments. It's the most common movement operator. <code>engine-power!</code> is a lower-level way of controlling the engine, which we use here to turn it off when there's nothing to eat.<p>It's easy to add a weapon to Animal, just like Killer Vegetable's.<h3>Wandering</h3><p>Animals tend to starve. When there's no food nearby, waiting for some to appear doesn't work very quickly. Why not go looking instead?<pre><code>#code#vector destnew-dest:  0 world-width random 0 world-height random dest!return#startnew-destdo  autoconstruct  44 periodic-food-sensor drop  food-found if    food-position seek-location  else    dest seek-location    position dest 3 in-range new-dest& ifc  thenforever</code></pre><p><code>new-dest</code> defines a label, which can be called as a user-defined operator, or passed as an argument to other operators, like <code>ifc</code>.<p>If execution started at the beginning of this type, it would blunder into <code>new-dest</code> and fail when trying to return from it. <code>#start</code> makes execution start elsewhere.<h3>Moving and fighting</h3><pre><code>#type Mineral#color FFF#hardware  processor 10  robot-sensor 10  blaster 25 3 25  engine .1  energy 200 5  solar-cells .12  armor 300#codedo  0 engine-power!  energy 20 &gt; if 57 periodic-robot-sensor and-if robot-found and-if    attack^  then  armor max-armor &lt; energy 10 &gt; and repair-rate!foreverattack:  robot-position robot-velocity seek-moving-location  do    blaster-reload-time periodic-robot-sensor if      robot-found if        robot-position robot-velocity lead-blaster        robot-position robot-velocity seek-moving-location      else        return ;nobody here - give up      then    then  energy armor min 20 &gt; while-loopreturn</code></pre><h2>General advice</h2><p>Read other sides. (But bear in mind that they don't always do things in the best way. In particular, old sides don't use newer features.) Try to figure out how they work. Modify them and see if you can do better.<p>Don't be afraid to learn math. In particular, vector arithmetic is easy and very useful. (It's useful for other things than Grobots, too.)<p>Don't try to make a side perfect from the beginning. Just try to make it do one thing well. You can improve the rest later.<p>Keep it simple. Complicated code is hard to debug and probably won't work much better. Don't try too hard to make it behave properly in all circumstances. For Grobots, code that works most of the time is almost as good as code that works all the time.<h2>Common behaviors</h2><h3>Type selection</h3><p>You can control what type a baby will be with <code>constructor-type!</code>. Types are numbered (not named, sorry) in order from 1. If you set <code>constructor-type</code> when there's already a baby in progress, it will abort, so it's usually set only when constructor-type is 0.<p>Most sides want to build whatever type they're short on. You can find out the populations with <code>type-population</code>:<pre><code>constructor-type nif  2 type-population 3 type-population &lt; 2 3 ifev constructor-type!then</code></pre><p><code>nif</code> is short for <code>not if</code>. <code>ifev</code> is a value conditional often used for this purpose.<h3>Shot-chasing</h3><p>Mineral ignores incoming shots, so an enemy with a long-range weapon can safely kill it. Most sides avoid this by watching for incoming shots, and following them back to their origin.<p>The simplest way to adapt Mineral to chase shots is to generalize <code>attack</code> to chase an arbitrary location, not just <code>robot-position</code>. Then when we see a shot, we can look at its velocity and attack the area it came from.<pre><code>do  0 engine-power!  energy 20 &gt; if 57 periodic-robot-sensor and-if robot-found and-if    robot-position attack^  then  energy armor min 50 &gt; if  ;only attack if we're healthy    15 periodic-shot-sensor if shot-found and-if      shot-velocity unitize -20 vs* shot-position v+ attack^    then  then  armor max-armor &lt; energy 10 &gt; and repair-rate!forever#vector target;;Go to a location and kill any enemies seen ;takes target as an argumentattack: ; tx ty --  target!  do    robot-found if      target robot-velocity seek-moving-location    else      target seek-location    then    blaster-reload-time periodic-robot-sensor if      robot-found if        robot-position robot-velocity lead-blaster        ;stay a short distance away from the target:        position robot-position v- unitize 2.5 vs*          robot-position v+ robot-velocity 10 vs* v+ target!      else        position target 3 in-range ifr ;nobody here - give up      then    then    robot-found nif 13 periodic-shot-sensor and-if shot-found and-if      shot-velocity unitize -20 vs* shot-position v+ target!    then  energy armor min 20 &gt; while-loopreturn</code></pre><p><p>Notice that a boolean is being used as <code>repair-rate</code>. Unlike real hardware, Grobots hardware is forgiving about out-of-range arguments, so when <code>repair-rate</code> is set to 1, it's treated as <code>max-repair-rate</code>.<h3>Swarming</h3><p>One fighter tends to die when facing a group. So let's make the fighters call for help when they see something. When they receive a call, they treat it just like chasing a shot:<pre><code>#const call-ch 5do  0 engine-power!  energy 20 &gt; if 57 periodic-robot-sensor and-if robot-found and-if    robot-position 2 call-ch send    robot-position attack^  then  energy armor min 50 &gt; if  ;only attack if we're healthy    15 periodic-shot-sensor if shot-found and-if      shot-velocity unitize -20 vs* shot-position v+        2dup 2 call-ch send attack^    then    call-ch receive attack& ifc  else    call-ch clear-messages ;so we don't respond to old calls  then  armor max-armor &lt; energy 10 &gt; and repair-rate!forever</code></pre><p><code>attack</code> doesn't change at all.<p>Places where there's been a recent call for help are often dangerous. It might be useful to make Animals avoid them when wandering.<h3>Running away</h3><p>Animal, like any gatherer, tends to wander near enemies and get killed. We can fix this by making it run away when it sees a shot. This is like chasing shots, but in the opposite direction.<p>Many sides run to somewhere well-defended (a stationary colony? a group of fighters?) instead of just running away, to avoid running into things. It's also possible to run away when damaged instead of watching for shots.<p>Animals could also call for help when they see a shot, or get hurt. This is easy to add to their shot-fleeing code.<!--<h3></h3><p><pre><code></code></pre><p>--><h3>Forcefields</h3><p>There are two main uses for forcefields: getting food and getting rid of enemies. Look at <a href='../sides/untouchable-3.gb'>Untouchable</a> or <a href='../sides/shepherds.gb'>Shepherds</a> for examples of both.<p>Exercise: Make a long-range gunner which uses a forcefield to make the target easier to hit. This has been tried a few times (in Flyswatter and early versions of Untouchable) but never with much success.<h3>Hiding</h3><p>The center of the world is a dangerous place to be. <a href='../sides/bombs-and-factories-5f.gb'>Productive</a> therefore goes to the nearest corner at the beginning of the round. Unfortunately it often runs into another side along the way and dies. More cautious hiding could be a large advantage in the early game.<p>Shepherds runs away as a group, and tends to end up in corners without trying. So does MicroAlgae. Unproductive accelerates this by deliberately moving next to a wall if one is close.<h3>Syphons</h3><p>Syphons let you separate energy production from consumption, giving more flexibility in side design. There are several ways to use them. The most popular is to have the energy producers carry the syphon, and hungry cells announce their locations in messages. The syphoners listen and point the syphons wherever they're asked.<!--<pre><code></code></pre><p>--><h2>Advanced tricks</h2><h3>Avoiding friendly fire</h3><p>Blasters can be hard to use in groups, because it's easy to hit your allies instead of enemies. One way to use them is to organize cells so they're unlikely to be in each other's way. If they avoid each other, or stay in a formation facing the enemy, they won't suffer much from friendly fire. Very short-range blasters avoid the problem by not having enough room for anyone to get in the way.<p><a href='../sides/noffee-4.gb'>Noffee</a> has a brute-force solution: it looks at nearby friendly cells and checks to see if they will be in the line of fire. This involves a lot of vector math. If you're willing to be more conservative about when you shoot, you can make this much simpler. Here's a version adapted from <a href='../sides/ring--of-fire-3.gb'>Ring of Fire 3</a>:<pre><code>#var target-distance#var blast-direction#vector blast-velocityshoot:  robot-distance target-distance!;aim the shot  robot-velocity velocity v- 2dup target-distance blaster-speed / vs* robot-position v+  position dist blaster-speed / vs* robot-position v+  position v- angle blast-direction!  velocity blaster-speed blast-direction polar-to-rect v+ blast-velocity!;look for friends  0 robot-sensor-sees-enemies!  1 robot-sensor-sees-friends!  target-distance 2 / robot-sensor-focus-distance!  blast-direction robot-sensor-focus-direction!  fire-robot-sensor sync  1 robot-sensor-sees-enemies!  0 robot-sensor-sees-friends!  0 robot-sensor-focus-distance!;anybody in the way?  robot-found if    do      robot-position position v- 2dup  ;vector to this robot        blast-velocity robot-velocity v- unitize dot  ;how far along the shot-path        dup radius &gt; swap target-distance &lt; and  ;is it between us and the target?        rrot blast-velocity robot-velocity v- unitize cross  ;distance from shot-path        abs robot-radius .2 + &lt; and ifr  ;...and is it close to the path?    next-robot while-loop  then;shoot  blast-direction fire-blasterreturn</code></pre><p>Obviously this takes a large processor and a multiresult sensor. The result is impressive: you can fire through the cracks in a crowd and rarely hit anyone.<h3>Food hashing</h3><p>Most gatherers waste a good deal of time when two cells are trying to eat the same food. Fool detects when it's been pushed off a food, and looks elsewhere. This is easy to implement.<p><a href='../sides/frog-celestial-2.gb'>Frog Celestial 2</a> has a fancy solution: it keeps a hashtable in shared memory, showing which foods have been claimed already:<pre><code>#comment   Food hashingKeep a hashtable of position -&gt; (time, x-position) showing who claims this food.Ignore foods other people have claimed recently.(x-position is used to confirm this is the right food.)Collisions are ignored; at worst they lead to pushing matches.Food hashing was first used in YAR, a not-yet-released side by Warren.#code#const hashtable-size 100#const hashtable-base 1#const claim-time 240food-hash:   ;(-- hash-index)  food-position + dup floor - epsilon / floor hashtable-size mod hashtable-base +returnclaim-food:   ;(-- claimed?)  food-energy 750 &gt; if 1 return then  do    food-velocity or nif      ;preload with (time t-addr x-pos x-addr time-threshold t-addr x-pos x-addr)      time food-hash dup hashtable-size + food-position drop swap      time claim-time - 2over over hashtable-size +      sync      read = if        read &gt; if write write 1 return        else 2drop 2drop then      else        2drop write write 1 return      then    then  next-food while-loop0 return;Then when you see food, call claim-food before trying to eat:  food-found if claim-food energy 20 &lt; or eat& ifg then  ;Eat anyway if we're short on energy.</code></pre><p>This is very effective, but complex. In order to update the hashtable atomically, it preloads some data on the stack.<p>You may want to try using some other method than a shared hashtable. Maybe use messages, and remember only the last few nearby claims. <a href='../sides/segregated-eaters.gb'>Segregated Eaters</a> keeps track of 10x10 tiles rather than individual foods. This is even more effective, because cells don't waste time wandering past foods that are taken.<address><a href='../'>Grobots</a> by <a href='mailto:dschudy@yahoo.com?subject=Grobots'>Devon Schudy</a>and <a href="mailto:wschudy@alum.wpi.edu?subject=Grobots">Warren Schudy</a></address>